#include "/Engine/Private/Common.ush"


uint cellOffsetBufferSize;
RWStructuredBuffer<uint> particleIndexBuffer;
RWStructuredBuffer<uint> cellIndexBuffer;   
RWStructuredBuffer<uint> cellOffsetBuffer; 

float cellSize;


uint numBoids;
uint numNeighbours;
float neighbourDistance;

RWStructuredBuffer<float3> positions; // Point Positions Input Buffer

RWStructuredBuffer<uint> neigbhours;
RWStructuredBuffer<uint> neighboursBaseIndex;
RWStructuredBuffer<uint> neighboursCount;

uint getFlatCellIndex(uint3 cellIndex)
{
    const uint p1 = 73856093; // some large primes
    const uint p2 = 19349663;
    const uint p3 = 83492791;
    int n = p1 * cellIndex.x ^ p2*cellIndex.y ^ p3*cellIndex.z;
    n %= cellOffsetBufferSize;
    return n;
}

[numthreads(256, 1, 1)]
void createUnsortedList(uint3 ThreadId : SV_DispatchThreadID)
{
   uint particleIndex = particleIndexBuffer[ThreadId.x];

   float3 position = positions[particleIndex];
   uint3 cellIndex = floor(position / cellSize);

   uint flatCellIndex = getFlatCellIndex(cellIndex);

   cellIndexBuffer[particleIndex] = flatCellIndex;
}

[numthreads(256, 1, 1)]
void createOffsetList(uint3 ThreadId : SV_DispatchThreadID)
{
    uint particleIndex = particleIndexBuffer[ThreadId.x];
    uint cellIndex = cellIndexBuffer[particleIndex];

    InterlockedMin(cellOffsetBuffer[cellIndex], ThreadId.x);
}





float distanceSqrd(float3 a, float3 b)
{
    float3 dir = a - b;
    return dot(dir, dir);
}

float3 safeNormal(float3 vec)
{
    float l = length(vec);
    
    return l > 0.0f ? vec / l : float3(0.0f, 0.0f, 0.0f);
}

[numthreads(256, 1, 1)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
    int index = ThreadId.x;

    float3 position = positions[index];
	
    uint baseIndex = neighboursBaseIndex[index];
    uint count = 0;
    
    const float neighbourDistanceSqrd = neighbourDistance * neighbourDistance;
	
    for (uint i = 0; i < numBoids; ++i)
    {
        if (i != index)
        {
            float3 otherPosition = positions[i];
            
            float distSqrd = distanceSqrd(position, otherPosition);
		
            if (distSqrd < neighbourDistanceSqrd)
            {
                neigbhours[baseIndex + count] = i;
			
                count++;
			
                if (count >= numNeighbours)
                    break;

            }
        }
    }
	
    neighboursCount[index] = count;
}