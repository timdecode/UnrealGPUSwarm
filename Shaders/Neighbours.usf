#include "/Engine/Private/Common.ush"

// This code is inspired by this blog post on dynamic hashed grids for scalable fluid simulations:
// https://wickedengine.net/2018/05/21/scalabe-gpu-fluid-simulation/

uint cellOffsetBufferSize;
RWStructuredBuffer<uint> particleIndexBuffer;
RWStructuredBuffer<uint> cellIndexBuffer;   
RWStructuredBuffer<uint> cellOffsetBuffer; 

float cellSize;
static const float cellSizeReciprocal = 1.0f / 20.0f;

uint numBoids;
uint numNeighbours;
float neighbourDistance;

RWStructuredBuffer<float3> positions; // Point Positions Input Buffer

RWStructuredBuffer<uint> neigbhours;
RWStructuredBuffer<uint> neighboursBaseIndex;
RWStructuredBuffer<uint> neighboursCount;

float timMod(float x, float y)
{
    return x - y * floor(x / y);
}

uint getFlatCellIndex(int3 cellIndex)
{

    const uint p1 = 73856093; // some large primes
    const uint p2 = 19349663;
    const uint p3 = 83492791;
    //int n = p1 * cellIndex.x ^ p2*cellIndex.y ^ p3*cellIndex.z;
    int n = cellIndex.x + cellIndex.y * 64 + cellIndex.z * 64 * 64;
    
    n = timMod(n, cellOffsetBufferSize);

    return n;
}

int3 positionToCellIndex(float3 position)
{
    //int3 index;
    
    //position *= cellSizeReciprocal;
    
    //index.x = position.x < 0.0f ? position.x - 1 : position.x;
    //index.y = position.y < 0.0f ? position.y - 1 : position.y;
    //index.z = position.z < 0.0f ? position.z - 1 : position.z;
    
    //return index;
    return floor(position * cellSizeReciprocal);
}

[numthreads(256, 1, 1)]
void createUnsortedList(uint3 ThreadId : SV_DispatchThreadID)
{  
    if (ThreadId.x >= numBoids)
        return;
    
    uint particleIndex = particleIndexBuffer[ThreadId.x];

    float3 position = positions[particleIndex];
    int3 cellIndex = positionToCellIndex(position);

    uint flatCellIndex = getFlatCellIndex(cellIndex);

    cellIndexBuffer[particleIndex] = flatCellIndex;
}

[numthreads(256, 1, 1)]
void resetParticleIndexBuffer(uint3 ThreadId : SV_DispatchThreadID)
{
    if (ThreadId.x >= numBoids)
        return;
    
    uint particleIndex = particleIndexBuffer[ThreadId.x];

    particleIndexBuffer[particleIndex] = particleIndex;
}

[numthreads(256, 1, 1)]
void createOffsetList(uint3 ThreadId : SV_DispatchThreadID)
{
    if (ThreadId.x >= numBoids)
        return;
    
  
    uint particleIndex = particleIndexBuffer[ThreadId.x];
   

    uint cellIndex = cellIndexBuffer[particleIndex];

    InterlockedMin(cellOffsetBuffer[cellIndex], ThreadId.x);
}

[numthreads(256, 1, 1)]
void resetCellOffsetBuffer(uint3 ThreadId : SV_DispatchThreadID)
{
    if (ThreadId.x >= cellOffsetBufferSize)
        return;
    
    cellOffsetBuffer[ThreadId.x] = 0xFFFFFFFF;
}



float distanceSqrd(float3 a, float3 b)
{
    float3 dir = a - b;
    return dot(dir, dir);
}

float3 safeNormal(float3 vec)
{
    float l = length(vec);
    
    return l > 0.0f ? vec / l : float3(0.0f, 0.0f, 0.0f);
}

[numthreads(256, 1, 1)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
    if (ThreadId.x >= numBoids)
        return;
    
    
    int index = ThreadId.x;

    float3 position_a = positions[index];
	
    uint baseIndex = neighboursBaseIndex[index];
    uint count = 0;
    
    const float neighbourDistanceSqrd = neighbourDistance * neighbourDistance;
	

    int3 cellIndex = positionToCellIndex(position_a);

    for(int i = -1; i <= 1; ++i)
    {
        for(int j = -1; j <= 1; ++j)
        {
            for(int k = -1; k <= 1; ++k)
            {
                int3 neighborIndex = cellIndex + int3(i, j, k);
                uint flatNeighborIndex = getFlatCellIndex(neighborIndex);

                // look up the offset to the cell:
                uint neighborIterator = cellOffsetBuffer[flatNeighborIndex];

                // iterate through particles in the neighbour cell (if iterator offset is valid)
                while(neighborIterator != 0xFFFFFFFF && neighborIterator < numBoids)
                {
                    uint particleIndexB = particleIndexBuffer[neighborIterator];

                    if (cellIndexBuffer[particleIndexB] != flatNeighborIndex || count >= numNeighbours)
                        break; // we hit the end of this neighbourhood list

                    float3 position_b = positions[particleIndexB];

                    float dist = distanceSqrd(position_b, position_a);

                    if( dist < neighbourDistanceSqrd && particleIndexB != index)
                    {
                        neigbhours[baseIndex + count] = particleIndexB;

                        count++;
                    }

                    neighborIterator++;  // iterate...
                }
            }
        }
    }
	
    neighboursCount[index] = count;
}

//[numthreads(256, 1, 1)]
//void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
//{
//    int index = ThreadId.x;

//    float3 position = positions[index];
	
//    uint baseIndex = neighboursBaseIndex[index];
//    uint count = 0;
    
//    const float neighbourDistanceSqrd = neighbourDistance * neighbourDistance;
	
//    for (uint i = 0; i < numBoids; ++i)
//    {
//        if (i != index)
//        {
//            float3 otherPosition = positions[i];
            
//            float distSqrd = distanceSqrd(position, otherPosition);
		
//            if (distSqrd < neighbourDistanceSqrd)
//            {
//                neigbhours[baseIndex + count] = i;
			
//                count++;
			
//                if (count >= numNeighbours)
//                    break;

//            }
//        }
//    }
	
//    neighboursCount[index] = count;
//}