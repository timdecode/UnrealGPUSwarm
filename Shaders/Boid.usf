//Since we can't #include private Engine shaders such as Common.ush we have to copy the needed Shaders from the Engine' Shader directory.
//When this gets chaned in the future, we could change this to #include "/Engine/Private/Common.ush".
#include "/Engine/Private/Common.ush"

//--------------------------------------------------------------------------------------
// Buffers
//--------------------------------------------------------------------------------------

float dt;
float totalTime;

float boidSpeed;
float boidSpeedVariation;
float boidRotationSpeed;

float separationDistance;
float homeInnerRadius;

RWStructuredBuffer<float3> positions;         // Point Positions Input Buffer

RWStructuredBuffer<float3> directions;

RWStructuredBuffer<uint> neigbhours;
RWStructuredBuffer<uint> neighboursBaseIndex;
RWStructuredBuffer<uint> neighboursCount;

//--------------------------------------------------------------------------------------
// Functions
//--------------------------------------------------------------------------------------
float hash( float n )
{
	return frac(sin(n)*43758.5453);
}

// The noise function returns a value in the range -1.0f -> 1.0f
float noise1( float3 x )
{
	float3 p = floor(x);
	float3 f = frac(x);

	f       = f*f*(3.0-2.0*f);
	float n = p.x + p.y*57.0 + 113.0*p.z;

	return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),
					lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),
				lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),
					lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
}

// CSVariables:
// float boidSpeed
// float boidSpeedVariation
// float dt
// float totalTime
// float neighbourDistance

float3 safeNormal(float3 vec, float3 safe)
{
    float l = length(vec);
    
    return l > 0.0f ? vec / l : safe;
}


//--------------------------------------------------------------------------------------
// Main
//--------------------------------------------------------------------------------------
[numthreads(256, 1, 1)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
    int index = ThreadId.x;

    const float3 position = positions[index];
    const float3 direction = directions[index];
    
	float noiseOffset = hash(float(index));

	float noise = clamp(noise1(totalTime / 100.0 + noiseOffset), -1, 1) * 2.0 - 1.0;
	float velocity = boidSpeed * (1.0 + noise * boidSpeedVariation);

    float3 separation = float3(0.0, 0.0, 0.0);
    float3 alignment = float3(0.0, 0.0, 0.0);
	float3 neighboursCentre = float3(0.0, 0.0, 0.0);


	uint count = neighboursCount[index];
	uint baseIndex = neighboursBaseIndex[index];

    // positions
    for (uint i = baseIndex; i < baseIndex + count; ++i)
    {
        int otherIndex = neigbhours[i];

        float3 otherPosition = positions[otherIndex];

        neighboursCentre += otherPosition;
		
        float3 dir = otherPosition - position;
        float dist = length(dir);
        
        if (dist < separationDistance && dist > 0.0f)
            separation -= (dir / dist) * (separationDistance - dist);
    }

    // cohesion
    neighboursCentre *= (count > 0 ? (1.0f / float(count)) : 0.0f);
    float3 cohesion = neighboursCentre - position;
    
    // directions
    for (uint i = baseIndex; i < baseIndex + count; ++i)
    {
        int otherIndex = neigbhours[i];

        alignment += directions[otherIndex];
    }
	
    alignment = safeNormal(alignment, direction);

    // home
    float3 home = float3(0.0f, 0.0f, 0.0f);
    
    float distFromHome = distance(home, position);
    
    float3 homeUrge = float3(0.0f, 0.0f, 0.0f);

    if (distFromHome > homeInnerRadius)
        homeUrge = safeNormal(home - position, float3(0.0f, 0.0f, 0.0f));

    

    float3 newDirection = alignment + separation + 0.2f * cohesion + 0.1f * homeUrge;

    float ip = exp(-boidRotationSpeed * dt);
    newDirection = lerp(newDirection, direction, ip);

    newDirection = safeNormal(newDirection, direction);
    
    positions[index] = position + newDirection * (velocity * dt);
    directions[index] = newDirection;
}




